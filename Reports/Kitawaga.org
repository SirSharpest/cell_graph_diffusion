* Setup
** Make initial graph and add some parameters
#+BEGIN_SRC ipython :session
  import pandas as pd
  import numpy as np
  import networkx as nx
  import matplotlib.pyplot as plt

  kit = pd.read_csv('./Data/kitagawa_estimations.csv')
  tp0 = kit[kit['H'] == 0].set_index('ABA').drop('H', axis=1)
  tp14 = kit[kit['H'] == 14].set_index('ABA').drop('H', axis=1)
  dt = 1
  # Setup graphs
  ABA = 0




  def init_Kitawaga_G():
      kit_vals = iter(tp0.loc[ABA].values)
      start, stop = -2, 3
      G = nx.Graph()
      for i in range(start, stop):
          G.add_node(i)
          G.nodes[i]['intensity'] = next(kit_vals)
          if i > start:
              G.add_edge(i-1, i)
      pos = {k:(k,0) for k, v in G.nodes(data=True)}
      return G, pos

  G, pos = init_Kitawaga_G()
  fig, ax = plt.subplots(1)
  _ = nx.draw(G, pos)
  _ = nx.draw_networkx_labels(G, pos, labels={k: v['intensity'] for k,v in G.nodes(data=True)} ,ax=ax)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [9]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/363e790216cf9d6f3f8ecbfe0f135097e39de36b.png]]
:END:

* Parameter balancing
** Simple single parameter optimising

#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info,  diffusion
  from scipy.optimize import leastsq

  G, pos = init_Kitawaga_G()
  A, C = extract_graph_info(G)
  R =  np.array([1e-5])
  dt = 60
  tt = (60*60*14) / dt # Number of model estimations to make
  kit14_vals = tp14.loc[ABA].values


  ydata = tp14.loc[ABA].values
  tmp = np.zeros(len(ydata)+2)
  tmp[1:-1] = ydata
  ydata = tmp
  xdata = np.arange(-3, 4)

  def edge_decay(A, R):
      # A is a 2D array
      B = np.diag(A).copy()
      B[0] = B[0] - R
      B[-1] = B[-1] - R
      B[B<0] = 0
      return np.diag(B)

  def minimise_R(x, R, gamma):
      A, C = extract_graph_info(G)
      X = np.zeros(len(A)+2)
      for _ in range(int(tt)):
          C = diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[ [gamma] ] )
      X[1:-1] = np.diag(C)
      return X
  # If we get straight line as results, then lower guessing threshold
  popt, pcov = curve_fit(minimise_R, xdata, ydata, p0=np.array([1e-30, 1e-30]), bounds=(0,0.5/dt ) )

  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  tt = (60*60*14) / dt # Number of model estimations to make
  R = np.array(popt[0])
  gamma = np.array(popt[-1])
  for _ in range(int(tt)):
      C = diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[[gamma]]  )
      X = C.copy()

  from network_diffusion import update_G_attribute
  vals = np.diag(np.around(C, 3))
  update_G_attribute(G, 'intensity', vals)
  import seaborn as sns
  sns.set()
  plt.plot(kit14_vals, label='Kitawga values',marker='o')
  plt.plot(vals, label='Model fit',marker='o')
  plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [340]:
# output
[(-2, {'intensity': 0.082}), (-1, {'intensity': 0.202}), (0, {'intensity': 0.281}), (1, {'intensity': 0.202}), (2, {'intensity': 0.082})]



# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/3e340b2842d2aad4050cc85bdd1e8f4f309e5f77.png]]
:END:


*** Balancing gamma as decay

#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info,  diffusion
  from scipy.optimize import leastsq

  G, pos = init_Kitawaga_G()
  A, C = extract_graph_info(G)
  R =  np.array([1e-5])
  dt = 60
  tt = (60*60*14) / dt # Number of model estimations to make
  kit14_vals = tp14.loc[ABA].values


  ydata = tp14.loc[ABA].values
  tmp = np.zeros(len(ydata)+2)
  tmp[1:-1] = ydata
  ydata = tmp
  xdata = np.arange(-3, 4)

  def decay(A, gamma):
      # A is a 2D array
      B = np.diag(A).copy()
      B = B*(1-gamma)
      B[B<0] = 0
      return np.diag(B)

  def minimise_R(x, R, gamma):
      A, C = extract_graph_info(G)
      X = np.zeros(len(A)+2)
      for _ in range(int(tt)):
          C = diffusion(A, C, R, dt, rules=[decay], rules_args=[ [gamma] ] )
      X[1:-1] = np.diag(C)
      return X
  # If we get straight line as results, then lower guessing threshold
  popt, pcov = curve_fit(minimise_R, xdata, ydata, p0=np.array([1e-30, 1e-30]), bounds=(0,0.5/dt ) )

  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  tt = (60*60*14) / dt # Number of model estimations to make
  R = np.array(popt[0])
  gamma = np.array(popt[-1])
  for _ in range(int(tt)):
      C = diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[[gamma]])
      X = C.copy()

  from network_diffusion import update_G_attribute
  vals = np.diag(np.around(C, 3))
  update_G_attribute(G, 'intensity', vals)
  import seaborn as sns
  sns.set()
  plt.plot(kit14_vals, label='Kitawga values',marker='o')
  plt.plot(vals, label='Model fit',marker='o')
  plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [341]:
# output
[(-2, {'intensity': 0.0}), (-1, {'intensity': 0.198}), (0, {'intensity': 0.346}), (1, {'intensity': 0.198}), (2, {'intensity': 0.0})]



# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/9e0f9f1a80cf462fa55c18ee641f8a36c2ded924.png]]
:END:


** Individual parameters

#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info, diffusion, weights_to_A
  from scipy.optimize import curve_fit
  import seaborn as sns
  sns.set()

  G, pos = init_Kitawaga_G()
  A, C = extract_graph_info(G)

  dt = 60
  tt = (60*60*14)/dt # Number of model estimations to make
  kit14_vals = tp14.loc[ABA].values


  ydata = tp14.loc[ABA].values
  tmp = np.zeros(len(ydata)+2)
  tmp[1:-1] = ydata
  ydata = tmp
  xdata = np.arange(-3, 4)

  def decay(A, gamma):
      # A is a 2D array
      B = np.diag(A).copy()
      B = B*(1-gamma)
      B[B<0] = 0
      return np.diag(B)

  def minimise_R(X, e1,e2,e3,e4,e5):
      A, C = extract_graph_info(G)
      X = np.zeros(len(A)+2)
      E = weights_to_A(G, np.array([e1, e2, e3, e4]))
      for _ in range(int(tt)):
          C = diffusion(A, C, E, dt, rules=[decay], rules_args=[[e5]], Mx=1)
      X[1:-1] = np.diag(C)
      return X

  popt, pcov = curve_fit(minimise_R, xdata, ydata, p0=np.array([1e-30, 1e-30, 1e-30, 1e-30, 1e-30]), bounds=(0,0.5/dt))

  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  R = np.array(popt)
  E = weights_to_A(G, R[:4])
  for _ in range(int(tt)):
      C = diffusion(A, C, E, dt, rules=[decay], rules_args=[[popt[-1]]], Mx=1)
      X = C.copy()
  print(np.diag(X))

  vals = np.diag(np.around(C, 3))
  plt.plot(kit14_vals, label='Kitawga values',marker='o')
  plt.plot(vals, label='Model fit',marker='o')
  plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [345]:
# output
[0.08 0.15 0.3  0.2  0.1 ]
[(-2, {'intensity': 0.08}), (-1, {'intensity': 0.15}), (0, {'intensity': 0.3}), (1, {'intensity': 0.2}), (2, {'intensity': 0.1})]



# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/45278ee5c2413756b9a222f410b646b56c808f0d.png]]
:END:



*** Test
#+BEGIN_SRC ipython :session
  G, pos = init_Kitawaga_G()
  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  R = np.array(popt)
  E = weights_to_A(G, R[:4])

  T = []
  for _ in range(int(tt*2)):
      C = diffusion(A, C, E, dt, rules=[edge_decay], rules_args=[R[-2:]], Mx=1)
      X = C.copy()
      T.append(np.diag(np.around(C, 3)))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [207]:
:END:



** Animate
#+BEGIN_SRC ipython :session
    from matplotlib.animation import FuncAnimation

    fig, ax = plt.subplots(1)

    def animate(i):
        vals = iter(T)
        ax.clear()
        ax.set_ylim(-0.1,1.1)
        data = [next(vals) for _ in range(int((60*60*(i))/dt)+1 )][-1]
        ax.set_title(f"{i} hours post photo-activation | control treatment")
        ax.plot(kit14_vals, label='Kitawga values',marker='o')
        p = ax.plot(data, label='Model estimation', marker='x')
        plt.legend()
        return p

    anim = FuncAnimation(fig, animate, frames=15, interval=200, blit=True)

    anim.save('test.gif', writer='imagemagick')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [215]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/29b9d42bdf77e3daa73e2c61a5db5ad17fd044c5.png]]
:END:



* Test for dynamic optimisation
#+BEGIN_SRC ipython :session

  from string import ascii_letters as letters


  N = 5
  l = iter(list(letters))
  i = [next(l) for _ in range(N)]
  args = ",".join(i)

  f_maker =f"""
  def f(X,{args}):
        A, C = extract_graph_info(G)
        X = np.zeros(len(A)+2)
        E = weights_to_A(G, np.array([{args}][:-1]))
        for _ in range(int(tt)):
            C = diffusion(A, C, E, dt, rules=[edge_decay], rules_args=[np.array([{args}][-1])], Mx=1)
        X[1:-1] = np.diag(C)
        return X
  """


  exec(f_maker)




#+END_SRC

#+RESULTS:
:RESULTS:
# Out [263]:
:END:
