* Setup
** Make initial graph and add some parameters
#+BEGIN_SRC ipython :session
  import pandas as pd
  import numpy as np
  import networkx as nx
  import matplotlib.pyplot as plt
  plt.xkcd()
  kit = pd.read_csv('./Data/kitagawa_estimations.csv')
  tp0 = kit[kit['H'] == 0].set_index('ABA').drop('H', axis=1)
  tp14 = kit[kit['H'] == 14].set_index('ABA').drop('H', axis=1)
  dt = 1
  # Setup graphs
  ABA = 0

  def init_Kitawaga_G(ABA=0):
      kit_vals = iter(tp0.loc[ABA].values)
      start, stop = -2, 3
      G = nx.Graph()
      for i in range(start, stop):
          G.add_node(i)
          G.nodes[i]['intensity'] = next(kit_vals)
          if i > start:
              G.add_edge(i-1, i)
      pos = {k:(k,0) for k, v in G.nodes(data=True)}
      return G, pos

  G, pos = init_Kitawaga_G()
  fig, ax = plt.subplots(1)
  _ = nx.draw(G, pos)
  _ = nx.draw_networkx_labels(G, pos, labels={k: v['intensity'] for k,v in G.nodes(data=True)} ,ax=ax)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [21]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/363e790216cf9d6f3f8ecbfe0f135097e39de36b.png]]
:END:

* Parameter balancing
** Simple single parameter optimising

#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info,  diffusion
  from scipy.optimize import leastsq, curve_fit

  G, pos = init_Kitawaga_G()
  A, C = extract_graph_info(G)
  R =  np.array([1e-5])
  dt = 60
  tt = (60*60*14) / dt # Number of model estimations to make
  kit14_vals = tp14.loc[ABA].values


  ydata = tp14.loc[ABA].values
  tmp = np.zeros(len(ydata)+2)
  tmp[1:-1] = ydata
  ydata = tmp
  xdata = np.arange(-3, 4)

  def edge_decay(A, R):
      # A is a 2D array
      B = np.diag(A).copy()
      B[0] = B[0] - R
      B[-1] = B[-1] - R
      B[B<0] = 0
      return np.diag(B)

  def minimise_R(x, R, gamma):
      A, C = extract_graph_info(G)
      X = np.zeros(len(A)+2)
      for _ in range(int(tt)):
          C = diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[ [gamma] ] )
      X[1:-1] = np.diag(C)
      return X
  # If we get straight line as results, then lower guessing threshold
  popt, pcov = curve_fit(minimise_R, xdata, ydata, p0=np.array([1e-30, 1e-30]), bounds=(0,0.5/dt ) )

  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  tt = (60*60*14) / dt # Number of model estimations to make
  R = np.array(popt[0])
  gamma = np.array(popt[-1])
  for _ in range(int(tt)):
      C = diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[[gamma]]  )
      X = C.copy()

  from network_diffusion import update_G_attribute
  vals = np.diag(np.around(C, 3))
  update_G_attribute(G, 'intensity', vals)

  plt.xkcd()
  plt.plot(kit14_vals, label='Kitawga values',marker='o')
  plt.plot(vals, label='Model fit',marker='o')
  plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [22]:
# output
[(-2, {'intensity': 0.065}), (-1, {'intensity': 0.212}), (0, {'intensity': 0.338}), (1, {'intensity': 0.212}), (2, {'intensity': 0.065})]



# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/f307aa7dd02f3f7fa54d4d0f0c35cf31b1ea6ef4.png]]
:END:


*** Balancing gamma as decay

#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info,  diffusion
  from scipy.optimize import leastsq

  G, pos = init_Kitawaga_G()
  A, C = extract_graph_info(G)
  R =  np.array([1e-5])
  dt = 60
  tt = (60*60*14) / dt # Number of model estimations to make
  kit14_vals = tp14.loc[ABA].values


  ydata = tp14.loc[ABA].values
  tmp = np.zeros(len(ydata)+2)
  tmp[1:-1] = ydata
  ydata = tmp
  xdata = np.arange(-3, 4)

  def decay(A, gamma):
      # A is a 2D array
      B = np.diag(A).copy()
      B = B*(1-gamma)
      B[B<0] = 0
      return np.diag(B)

  def minimise_R(x, R, gamma):
      A, C = extract_graph_info(G)
      X = np.zeros(len(A)+2)
      for _ in range(int(tt)):
          C = diffusion(A, C, R, dt, rules=[decay], rules_args=[ [gamma] ] )
      X[1:-1] = np.diag(C)
      return X
  # If we get straight line as results, then lower guessing threshold
  popt, pcov = curve_fit(minimise_R, xdata, ydata, p0=np.array([1e-30, 1e-30]), bounds=(0,0.5/dt ) )

  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  tt = (60*60*14) / dt # Number of model estimations to make
  R = np.array(popt[0])
  gamma = np.array(popt[-1])
  for _ in range(int(tt)):
      C = diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[[gamma]])
      X = C.copy()

  from network_diffusion import update_G_attribute
  vals = np.diag(np.around(C, 3))
  update_G_attribute(G, 'intensity', vals)

  plt.xkcd()
  plt.plot(kit14_vals, label='Kitawga values',marker='o')
  plt.plot(vals, label='Model fit',marker='o')
  plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [23]:
# output
[(-2, {'intensity': 0.0}), (-1, {'intensity': 0.203}), (0, {'intensity': 0.405}), (1, {'intensity': 0.203}), (2, {'intensity': 0.0})]



# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/6bbf6de2d47eea2bda34535f4c9c0458c9c55a98.png]]
:END:


** Individual parameters

#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info, diffusion, weights_to_A
  from scipy.optimize import curve_fit



  G, pos = init_Kitawaga_G()
  A, C = extract_graph_info(G)

  dt = 60
  tt = (60*60*14)/dt # Number of model estimations to make
  kit14_vals = tp14.loc[ABA].values


  ydata = tp14.loc[ABA].values
  tmp = np.zeros(len(ydata)+2)
  tmp[1:-1] = ydata
  ydata = tmp
  xdata = np.arange(-3, 4)

  def decay(A, gamma):
      # A is a 2D array
      B = np.diag(A).copy()
      B = B*(1-gamma)
      B[B<0] = 0
      return np.diag(B)

  def minimise_R(X, e1,e2,e3,e4,e5):
      A, C = extract_graph_info(G)
      X = np.zeros(len(A)+2)
      E = weights_to_A(G, np.array([e1, e2, e3, e4]))
      for _ in range(int(tt)):
          C = diffusion(A, C, E, dt, rules=[decay], rules_args=[[e5]], Mx=1)
      X[1:-1] = np.diag(C)
      return X

  popt, pcov = curve_fit(minimise_R, xdata, ydata, p0=np.array([1e-30, 1e-30, 1e-30, 1e-30, 1e-30]), bounds=(0,0.5/dt))

  print(popt)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [24]:
# output
[1.20749464e-05 9.18778872e-06 1.53511286e-05 1.93894286e-05
 1.93456201e-04]

:END:




** Animate

#+BEGIN_SRC ipython :session
from matplotlib.animation import FuncAnimation
plt.xkcd()
A, C = extract_graph_info(G)
X = np.zeros(A.shape)
R = np.array(popt)
E = weights_to_A(G, R[:4])
T= []
for _ in range(int(tt*10)):
    C = diffusion(A, C, E, dt, rules=[decay], rules_args=[[popt[-1]]], Mx=1)
    X = C.copy()
    T.append(np.diag(X))
fig, ax = plt.subplots(1)

def animate(i):
    ax.clear()
    ax.set_ylim(-0.1,1.1)
    data = T[int(i*60*30/dt)]
    ax.set_title(f"{i/2} hours post photo-activation | control treatment")
    ax.plot(kit14_vals, label='Kitawga values',marker='o')
    p = ax.plot(data, label='Model estimation', marker='x')
    plt.legend()
    return p

anim = FuncAnimation(fig, animate, frames=30, interval=200, blit=True)

anim.save('simulate_kit_ctrl_tmp.gif', writer='imagemagick')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [25]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/1f1ea0201a08ac39f1348862b6e7e47774229ab8.png]]
:END:



* Test for dynamic optimisation

** Method for fitting different G

#+BEGIN_SRC ipython :session
def fit(G, ydata, tt, dt=60):

  def decay(A, gamma):
    # A is a 2D array
    B = np.diag(A).copy()
    B = B*(1-gamma)
    B[B<0] = 0
    return np.diag(B)

  tmp = np.zeros(len(ydata)+2)
  tmp[1:-1] = ydata
  ydata = tmp
  xdata = np.arange(-3, 4)
  tt = tt/dt # Number of model estimations to make

  def f(x, *xargs):
    A, C = extract_graph_info(G)
    Y = np.zeros(len(A)+2)
    E = weights_to_A(G, np.array(xargs[:-1]))
    for _ in range(int(tt)):
      C = diffusion(A, C, E, dt, rules=[decay], rules_args=[[xargs[-1]]], Mx=1)
    Y[1:-1] = np.diag(C)
    return Y
  p0 = np.array([1e-6 for _ in range(len(G.nodes))])
  p0[-1] = p0[-1]/100
  popt, pcov = curve_fit(f, xdata, ydata,
                         p0=p0,
                         bounds=(0, 0.5/dt))
  return popt, pcov
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [33]:
:END:


#+BEGIN_SRC ipython :session
G, pos = init_Kitawaga_G()
A, C = extract_graph_info(G)
dt = 60
ydata = tp14.loc[ABA].values
tt=60*60*14
popt, pcov = fit(G, ydata, tt)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [34]:
:END:


#+BEGIN_SRC ipython :session
A, C = extract_graph_info(G)
X = np.zeros(A.shape)
R = np.array(popt)
E = weights_to_A(G, R[:-1])

T= []
for _ in range(int(tt/dt)):
    C = diffusion(A, C, E, dt, rules=[decay], rules_args=[[popt[-1]]], Mx=1)
    X = C.copy()
    T.append(np.diag(X))

plt.xkcd()
fig, ax = plt.subplots(1)
ax.plot(T[-1], label='model prediction', marker='x', alpha=0.3)
ax.plot(ydata, label='actual', marker='o', alpha=0.3)
ax.legend()
#ax.set_ylim(0,1)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [35]:


# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/5e9e7786ca13002248f281ca1eae232b1e260e62/e906e4aace0d117e7a1113b3fa13057a942582f8.png]]
:END:


** Model different ABA quantities

#+BEGIN_SRC ipython :session
  def model_kit_and_plot(ABA, ax=None):
      G, pos = init_Kitawaga_G(ABA)
      A, C = extract_graph_info(G)
      dt = 60
      ydata = tp14.loc[ABA].values
      tt=60*60*14
      popt, pcov = fit(G, ydata, tt)

      A, C = extract_graph_info(G)
      X = np.zeros(A.shape)
      R = np.array(popt)
      E = weights_to_A(G, R[:-1])

      T= []
      for _ in range(int(tt/dt)):
          C = diffusion(A, C, E, dt, rules=[decay], rules_args=[[popt[-1]]], Mx=1)
          X = C.copy()
          T.append(np.diag(X))
      if ax is None:
          fig, ax = plt.subplots(1)
      ax.plot(T[-1], label='model prediction', marker='x', alpha=0.7)
      ax.plot(ydata, label='actual', marker='o', alpha=0.3)
      if ABA == 0:
          ax.legend()
      ax.set_title(f"ABA value: {ABA} | 14 hours post treatment")

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [39]:
:END:


#+BEGIN_SRC ipython :session :ipyfile '((:name "ABA Modelled" :filename "obipy-resources/ABA Modelled.png" :caption "Modelled ABA from Kitawaga 2018" :attr_html ":width 450px" :attr_latex ":width 15cm"))
  fig, axes = plt.subplots(2,3, sharey=True, sharex=True, figsize=(15,7))
  plt.xkcd()
  ax = iter(axes.ravel())
  for ABA in tp14.index.values:
      model_kit_and_plot(ABA, ax=next(ax))
      plt.xkcd()
  next(ax).remove()
  fig.tight_layout()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [40]:
# text/plain
: <Figure size 1080x504 with 5 Axes>

# image/png
#+attr_html: :width 450px
#+attr_latex: :width 15cm
#+caption: Modelled ABA from Kitawaga 2018
#+name: ABA Modelled
[[file:obipy-resources/ABA Modelled.png]]
:END:
