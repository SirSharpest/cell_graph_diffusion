#+TITLE: Diffusion on a graph

* Setup

  #+BEGIN_SRC ipython :session :ipyfile '((:name "network" :filename "obipy-resources/network.png" :caption "" :attr_html ":width 350px" :attr_latex ":width 15cm"))
  from image_to_network import get_network_from_paired
  import numpy as np
  import networkx as nx
  import matplotlib.pyplot as plt

  g = get_network_from_paired("./Paired/col0_20.png")
  pos = {}
  for idx in list(g.nodes):
      pos[idx] = (np.array(g.nodes[idx]['centroid'])[::-1])


  fig, ax = plt.subplots(1)
  nx.draw(g, pos, ax=ax, with_labels=True)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [1994]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
#+attr_html: :width 350px
#+attr_latex: :width 15cm
#+caption:
#+name: network
[[file:obipy-resources/network.png]]
:END:


#+BEGIN_SRC ipython :session :ipyfile '((:name "diffusion" :filename "obipy-resources/diffusion.png" :caption "" :attr_html ":width 350px" :attr_latex ":width 15cm"))

  import network_diffusion
  np.random.seed(1994)

  A,C = network_diffusion.extract_graph_info(g)
  R = 1/100
  dt = 1

  def plot_network(g, C):
      fig, ax = plt.subplots(1)
      _ = nx.draw(g, pos, ax=ax, with_labels=False, node_size=np.diag(C)*1000)
      _ = nx.draw_networkx_labels(g, pos, labels={k: np.around(v,2) for k, v in zip(list(g.nodes), np.diag(C))} , ax=ax)

  plot_network(g, C)


  Cs = []
  for i in range(10):
      C = network_diffusion.beta_diffusion(A, C, R, 2)
      Cs.append(C)
  plot_network(g, Cs[-1])


#+END_SRC

#+RESULTS:
:RESULTS:
# Out [2007]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
#+attr_html: :width 350px
#+attr_latex: :width 15cm
#+caption:
#+name: diffusion
[[file:obipy-resources/diffusion.png]]

# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/094d829fb814646df9eee340e2c94aa36947cf2d/296a0f49b536439625c1c8f71d64cbd85ed43f32.png]]
:END:


*** Play with weights
#+BEGIN_SRC ipython :session
  g = get_network_from_paired("./Paired/col0_20.png")
  A = nx.to_numpy_matrix(g)
  R = A/2

  edge_conv = {}
  for idx, (n,d) in enumerate(g.nodes(data=True)):
      edge_conv[idx] = n
      print(n,d)

  edges = []
  A = np.triu(A)
  for i,j in np.ndindex(A.shape):
     if A[j,i] > 0:
        edges.append((edge_conv[j],edge_conv[i], {"weight": R[j,i]}))


  for u,v,a in g.edges(data=True):
      print(u, v, a)





#+END_SRC

#+RESULTS:
:RESULTS:
# Out [808]:
# output
1 {'labels': [1], 'centroid': (436, 510), 'uid': 0, 'intensity': 0.98}
2 {'labels': [2], 'centroid': (407, 438), 'uid': 1, 'intensity': 0.2}
4 {'labels': [4], 'centroid': (538, 515), 'uid': 2, 'intensity': 0.16}
5 {'labels': [5], 'centroid': (455, 556), 'uid': 3, 'intensity': 0.83}
6 {'labels': [6], 'centroid': (485, 430), 'uid': 4, 'intensity': 0.59}
7 {'labels': [7], 'centroid': (494, 555), 'uid': 5, 'intensity': 0.24}
1 2 {'weight': 1.0, 'count': 206}
1 4 {'weight': 1.0, 'count': 314}
1 5 {'weight': 1.0, 'count': 211}
1 6 {'weight': 1.0, 'count': 160}
2 6 {'weight': 1.0, 'count': 192}
4 5 {'weight': 1.0, 'count': 67}
4 6 {'weight': 1.0, 'count': 89}
4 7 {'weight': 1.0, 'count': 219}
5 7 {'weight': 1.0, 'count': 216}

:END:



** Fix stuff
#+BEGIN_SRC ipython :session
  nums = iter(np.arange(0, 100))
  for n in g.nodes():
      g[n]['name'] = next(nums)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [116]:
# output
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-116-208ef8227a36> in <module>
      1 nums = iter(np.arange(0, 100))
      2 for n in g.nodes:
----> 3     g[n]['name'] = next(nums)

TypeError: 'AtlasView' object does not support item assignment
:END:


** Test matrix multiplications work out
#+BEGIN_SRC ipython :session
A = np.array([[0,1,0], [1,0,1], [0,1,0]])
C = np.array([[0.2,0,0], [0,1,0], [0,0,0.6]])
D = np.array([[1,0,0], [0,2,0], [0,0,1]])
R = 1/10
O = C*R*D
I = np.diag(np.sum((A * np.sum(C*R, axis=1)), axis=1) )
Cn = C - O + I
print(C)
print('\n')
print(f'variables given are O:\n{O} \n \n I:\n{I}')
print('\n')
print(Cn)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [562]:
# output
[[0.2 0.  0. ]
 [0.  1.  0. ]
 [0.  0.  0.6]]


variables given are O:
[[0.02 0.   0.  ]
 [0.   0.2  0.  ]
 [0.   0.   0.06]]

 I:
[[0.1  0.   0.  ]
 [0.   0.08 0.  ]
 [0.   0.   0.1 ]]


[[0.28 0.   0.  ]
 [0.   0.88 0.  ]
 [0.   0.   0.64]]

:END:


*** Test they work for variable R

#+BEGIN_SRC ipython :session
A = np.array([[0,1,0], [1,0,1], [0,1,0]])
C = np.array([[0.2,0,0], [0,1,0], [0,0,0.6]])
D = np.array([[1,0,0], [0,2,0], [0,0,1]])
r = 1/10
R = A*r # Still keeping solid 1/10 factor to test

O = np.diag(np.sum((R*np.diag(C)), axis=0))
I = np.diag(np.sum(R*np.diag(C), axis=1))

Cn = C - O + I
print(C)

Cn = Cn - O + I
print(Cn)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [1116]:
# output
[[0.2 0.  0. ]
 [0.  1.  0. ]
 [0.  0.  0.6]]
[[0.36 0.   0.  ]
 [0.   0.76 0.  ]
 [0.   0.   0.68]]

:END:



*** Fix WRT to R proper representations

#+BEGIN_SRC ipython :session
A = np.array([[0,1,0], [1,0,1], [0,1,0]])
C = np.array([[1,0,0], [0,0.5,0], [0,0,1]])
D = np.array([[1,0,0], [0,2,0], [0,0,1]])
Mx = 1/20 # 5pc, this can be set from what we observe in the literature for transfer rates
R = A*Mx
Ex = R*np.diag(C)
Ex[Ex > Mx]=Mx
O = np.diag(np.sum(Ex, axis=0))
I = np.diag(np.sum(Ex, axis=1))


Cn = C - O + I

print(C)
print('\n')
print(np.sum(C))
print('\n')


print(Cn)
print('\n')
print(np.sum(Cn))

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [2196]:
# output
[[1.  0.  0. ]
 [0.  0.5 0. ]
 [0.  0.  1. ]]


2.5


[[0.975 0.    0.   ]
 [0.    0.55  0.   ]
 [0.    0.    0.975]]


2.5

:END:


#+BEGIN_SRC ipython :session
  from network_diffusion import update_edge_weights, weights_to_A

  g = get_network_from_paired("./Paired/col0_20.png")
  A, C = extract_graph_info(g)
  edge_weights = np.around(np.random.rand(len(g.edges)), 2)

  print(weights_to_A(g, edge_weights))

  # weight_mat = np.triu(A)

  # list_of_coords = np.where(weight_mat == 1)
  # weight_mat[list_of_coords] = edge_weights

  # print(weight_mat)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [1538]:
# output
[[0.   0.98 0.22 0.38 0.5  0.  ]
 [0.   0.   0.   0.   0.93 0.  ]
 [0.   0.   0.   0.94 0.82 0.87]
 [0.   0.   0.   0.   0.   0.46]
 [0.   0.   0.   0.   0.   0.  ]
 [0.   0.   0.   0.   0.   0.  ]]

:END:



#+BEGIN_SRC ipython :session

#+END_SRC


* Diffusion

/n.b./ $R$ cannot exceed $1/D_i$

For network diffusion we use the adjacency matrix $A$ the concentration matrix $C$ and the exchange per connection (i.e. PD rate) $R$ to calculate the incoming and outgoing concentration of some molecule. To calculate the outgoing we use the following:

\begin{equation}
O_{t+1} = C_tRD
\end{equation}

Here, we take the concentration matrix, the degree matrix $D$ and exchange per connection to find how much will leave each cell.


Next we calculate the incoming of each cell:


\begin{equation}
I_{t+1} = E \times \sum^{n}_{m}(A(\sum^{i}_{j} (C_tR)_j))_m
\end{equation}


We sum over the matrix $CR$ row-by-row, to calculate the expected loss of each cell represented by a $1 \times N$ vector. We can combine this with the adjacency matrix $A$ to give a matrix of $N \times N$ which if summed row-by-row will give another $1 \times N$ vector of incoming concentrations from connected nodes. Multiply this with an $N \times N$ matrix $E$ where $E_{n=m} = 1$ and $0$ elsewhere.


Both of these together give a simple solution for concentration exchange, where the concentration matrix at $t+1$ is equal to:

\begin{equation}
C_{t+1} = C_t - O_{t+1} + I_{t+1}
\end{equation}

Which we expand into a rules based system easily by allowing for the altercation of $C$ by modifying this to be:
\begin{equation}
C_{t+1} = f(C_t) - g(O_{t+1}) + h(I_{t+1})
\end{equation}

where $f, g, h$ are pure functions, or a series of functions, which would affect concentration change in cells e.g. some production or decay function.
