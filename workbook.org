#+BEGIN_SRC ipython :session
from glob import glob as gb
import numpy as np
import matplotlib.pyplot as plt
files = gb("/Users/hughesn/PHD/Datasets/Images/Faulkner2013/Normalised/30nov11_Col0_mRFP.lif/*.png")

img_loc = files[0]
orig = plt.imread(img_loc)
orig = orig[:,:,:3]
image = np.copy(orig)
mask = np.where(image[:, :, 0] > 200)
edge_map = np.zeros(image.shape)
edge_map[mask] = [1, 1, 1]
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [4]:
:END:



* Mass conversions

#+BEGIN_SRC ipython :session :ipyfile '((:name "graph" :filename "obipy-resources/graph.png" :caption "" :attr_html ":width 450px" :attr_latex ":width 15cm"))
from image_to_network import make_network as mw
from glob import glob as gb
import matplotlib.pyplot as plt
from skimage.io import imread

files = gb("/Users/hughesn/PHD/Datasets/Images/Faulkner2013/Normalised/30nov11_Col0_mRFP.lif/*.png")
idx = 2
gs = mw(imread(files[idx])[:,:,:3], draw=True, save_loc=f"./graphs/{idx}.png")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [7]:
# text/plain
: <Figure size 3000x3000 with 5 Axes>

# image/png
#+attr_html: :width 450px
#+attr_latex: :width 15cm
#+caption:
#+name: graph
[[file:obipy-resources/graph.png]]
:END:


* Quantify cells

#+BEGIN_SRC ipython :session
  from skimage.measure import label, regionprops
  import numpy as np
  import matplotlib.pyplot as plt
  from image_to_network import get_img_labels_edge_map, read_img_pair
  from glob import glob as gb
  paired = gb('./Paired/*.png')
  p = paired[0]
  inp, mask = read_img_pair(p)
  orig, image_labels, edge_map = get_img_labels_edge_map(mask)
  props = regionprops(image_labels)
  mask2d = np.zeros(image_labels.shape)
  for p in props:
      x, y = np.split(p.coords, [-1], axis=1)
      mask2d[x, y] = 1
      image_overlayed = np.where(mask2d[..., None], inp, 0)
  plt.imshow(mask)
  plt.grid('off')

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [8]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/d7d2d51a7ffbf36a765043ab9f241048a20912e0.png]]
:END:

#+BEGIN_SRC ipython :session
plt.imshow(plt.imread(paired[4]))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [12]:


# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/96595ce89b8fcb463841dac2df67dd17fb16ebda.png]]
:END:



#+BEGIN_SRC ipython :session
  from image_to_network import get_network_from_paired
  g = get_network_from_paired(paired[1])
  inp, mask = read_img_pair(paired[1])
  import networkx as nx
  fig, ax = plt.subplots(1, figsize=(10,10))
  pos = {}
  for idx in list(g.nodes):
      pos[idx] = (np.array(g.nodes[idx]['centroid'])[::-1])
  ax.imshow(mask)
  _ = nx.draw(g, pos, with_labels=False, ax=ax)
  _ = nx.draw_networkx_labels(g, pos, labels={k: v['intensity'] for k,v in g.nodes(data=True)} ,ax=ax)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [72]:
# text/plain
: <Figure size 720x720 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/9890d7a5d5e1cff5331bd3c1106e036739fe5daa.png]]
:END:


#+BEGIN_SRC ipython :session
from image_to_network import make_network
from skimage.color import label2rgb, rgb2gray
inp, mask = read_img_pair(paired[1])
g = make_network(mask)
_, image_labels, edge_map = get_img_labels_edge_map(mask)

def calc_grayvalues(inp, image_labels, g):
    props = regionprops(image_labels)

    grayvals = {}
    for (idx, _), p in zip(g.nodes(data=True), props):
        mask2d = np.zeros(image_labels.shape)
        x, y = np.split(p.coords, [-1], axis=1)
        mask2d[x, y] = 1
        cell = np.where(mask2d, rgb2gray(inp), 0)
        grayvals[idx] = np.around(np.sum(cell)/p.area, 2)
    return grayvals

calc_grayvalues(inp, image_labels, g)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [75]:
# text/plain
: {1: 0.81,
:  2: 0.29,
:  3: 0.25,
:  4: 0.32,
:  5: 0.19,
:  7: 0.41,
:  8: 0.72,
:  9: 0.19,
:  12: 0.13}
:END:


* Estimate Kitawaga
#+BEGIN_SRC ipython :session
  import pandas as pd
  import numpy as np
  import networkx as nx
  import matplotlib.pyplot as plt
  kit = pd.read_csv('./Data/kitagawa_estimations.csv')
  tp0 = kit[kit['H'] == 0].set_index('ABA').drop('H', axis=1)
  tp14 = kit[kit['H'] == 14].set_index('ABA').drop('H', axis=1)
  dt = 1
  # Setup graphs
  ABA = 0

  kit_vals = iter(tp0.loc[ABA].values)

  start, stop = -2, 3
  G = nx.Graph()
  for i in range(start, stop):
      G.add_node(i)
      G.nodes[i]['intensity'] = next(kit_vals)
      if i > start:
          G.add_edge(i-1, i)
  pos = {k:(k,0) for k, v in G.nodes(data=True)}
  fig, ax = plt.subplots(1)
  _ = nx.draw(G, pos)
  _ = nx.draw_networkx_labels(G, pos, labels={k: v['intensity'] for k,v in G.nodes(data=True)} ,ax=ax)


#+END_SRC

#+RESULTS:
:RESULTS:
# Out [81]:
# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/363e790216cf9d6f3f8ecbfe0f135097e39de36b.png]]
:END:

#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info, diffuser, beta_diffusion
  A, C = extract_graph_info(G)
  dt = 0.5
  Cs = []
  # Testing over a 12hr simulation!
  for i in range(int((12*60*60)/dt)):
      C = beta_diffusion(A, C, 0.1, dt)
      Cs.append(C)
  print(np.around(C,3))
  print(np.sum(C))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [94]:
# output
[[0.2 0.  0.  0.  0. ]
 [0.  0.2 0.  0.  0. ]
 [0.  0.  0.2 0.  0. ]
 [0.  0.  0.  0.2 0. ]
 [0.  0.  0.  0.  0.2]]
1.0000000000000009

:END:



#+BEGIN_SRC ipython :session
  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  tt = (60*60*14) / dt # Number of model estimations to make
  def edge_decay(A, R):
      # A is a 2D array
      B = np.diag(A).copy()
      B[0] = B[0] - R
      B[-1] = B[-1] - R
      B[B<0] = 0
      return np.diag(B)
  R = np.array([2.08806883e-05])

  for _ in range(int(tt)):
      C = beta_diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[[R[0]]])
      X = C.copy()
  print(np.diag(np.around(C, 3)))
  print(np.sum(np.diag(np.around(C, 3))))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [103]:
# output
[0.115 0.217 0.3   0.217 0.115]
0.964

:END:


#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info, diffuser, beta_diffusion
  from scipy.optimize import leastsq

  A, C = extract_graph_info(G)
  R =  np.array([1e-5])
  dt = 60
  tt = (60*60*14) / dt # Number of model estimations to make

  kit14_vals = tp14.loc[ABA].values

  def edge_decay(A, R):
      # A is a 2D array
      B = np.diag(A).copy()
      B[0] = B[0] - R
      B[-1] = B[-1] - R
      B[B<0] = 0
      return np.diag(B)

  def minimise_R(R):
      A, C = extract_graph_info(G)
      X = np.zeros(A.shape)
      for _ in range(int(tt)):
          C = beta_diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[[R[0]]] )
          X = C.copy()
      X = np.diag(X)
      err = np.square(X[2] - kit14_vals[2])
      return err

  popt, pcov = leastsq(minimise_R, 0)

  print(popt)
  print(pcov)

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [97]:
# output
[2.08806883e-05]
2

:END:

#+BEGIN_SRC ipython :session
  import seaborn as sns
  sns.set()
  R = popt

  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  for _ in range(int(tt)):
      C = beta_diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[[R[0]]] )
      X = C.copy()
  model_output = np.diag(X)

  plt.plot(kit14_vals, label='Kitawga values')
  plt.plot(model_output, label='Model fit')
  plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [10]:
# output

NameErrorTraceback (most recent call last)
<ipython-input-10-673260745eaf> in <module>
      1 import seaborn as sns
      2 sns.set()
----> 3 R = popt
      4
      5 A, C = extract_graph_info(G)

NameError: name 'popt' is not defined
:END:



** The meaning of R
In our models, R is given as a percentage value for which a single cell-to-cell connection can exchange.
R is used to


#+BEGIN_SRC ipython :session
print(f"This shows that the loss percentage per cell per minute is {R}")
print(f"Or to be more understandable: each cell exchanges {(R*60):.2f}% per neighbour")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [996]:
# output
This shows that the loss percentage per cell per minute is 0.06997177992896
Or to be more understandable: each cell exchanges 4.20% per neighbour

:END:

How does this compare to the ground truth?

#+BEGIN_SRC ipython :session
t0 = 1
t14 = kit14_vals[2]
p_change = t0-t14
print(f"This would give the primary cell an expected loss of {(p_change*100)/14:.2f}% concentration per hour")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [997]:
# output
This would give the primary cell an expected loss of 5.00% concentration per hour

:END:


** Minimise for all R

#+BEGIN_SRC ipython :session
  from network_diffusion import extract_graph_info, diffusion
  from scipy.optimize import curve_fit

  G, pos = init_Kitawaga_G()
  A, C = extract_graph_info(G)
  dt = 10
  tt = (60*60) / dt # Number of model estimations to make

  ydata = tp14.loc[ABA].values
  tmp = np.zeros(len(ydata)+2)
  tmp[1:-1] = ydata
  ydata = tmp
  xdata = np.arange(-3, 4)


  def edge_decay(A, edge1, edge2):
      # A is a 2D array
      B = np.diag(A).copy()
      B[0] = B[0] - edge1
      B[-1] = B[-1] - edge2
      B[B<0] = 0
      return np.diag(B)


  def minimise_R_mv(x, e1, e2, e3, e4, e5, e6):
      A, C = extract_graph_info(G)
      X = np.zeros(len(A)+2)
      E = weights_to_A(G, np.array([e1, e2, e3, e4]))
      for _ in range(int(tt)):
          C = diffusion(A, C, E, dt, rules=[edge_decay], rules_args=[np.array([e5,e6])], Mx=1)
      X[1:-1] = np.diag(C)
      return X

  popt, pcov = curve_fit(minimise_R_mv, xdata, ydata, p0=np.array([1e-3, 1e-3, 1e-3, 1e-3, 1e-3, 1e-3 ]), bounds=(0,0.5))


  A, C = extract_graph_info(G)
  X = np.zeros(A.shape)
  R = np.array(popt)
  E = weights_to_A(G, R[:4])
  for _ in range(int(tt)):
      C = diffusion(A, C, E, dt, rules=[edge_decay], rules_args=[R[-2:]], Mx=1)
      X = C.copy()

  from network_diffusion import update_G_attribute
  vals = np.diag(np.around(C, 3))
  update_G_attribute(G, 'intensity', vals)
  import seaborn as sns
  sns.set()
  plt.plot(kit14_vals, label='Kitawga values',marker='o', alpha=0.3)
  plt.plot(vals, label='Model fit',marker='o', alpha=0.3)
  plt.legend()

#+END_SRC

#+RESULTS:
:RESULTS:
# Out [286]:
# output
[(-2, {'intensity': 0.08}), (-1, {'intensity': 0.15}), (0, {'intensity': 0.3}), (1, {'intensity': 0.2}), (2, {'intensity': 0.1})]



# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/e5e1437e29d1c6ccc2fdf38689b3c4d379c39d4c.png]]
:END:



#+BEGIN_SRC ipython :session
  import seaborn as sns
  sns.set()
  dt = 60
  A, C = extract_graph_info(G)
  R = weights_to_A(G, np.array(popt)[:-2] )
  for _ in range(int(tt)):
      C = diffusion(A, C, R, dt, rules=[edge_decay], rules_args=[ popt[-2:]], Mx=1 )
  model_output = np.diag(C)
  plt.plot(ydata[1:-1], label='Kitawga values', linestyle='-', alpha=0.7)
  plt.plot(model_output, label='Model fit', linestyle='-', alpha=0.7)
  plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [85]:


# text/plain
: <Figure size 432x288 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/a757150eeb06b3a635f4a2577afc4f38691d9261.png]]
:END:

*** Meaning of R pt2


Here we show that for cells -2 through to +2 is:

#+BEGIN_SRC ipython :session
print(popt[:-2])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [2076]:
# output
[2.20187184e-05 1.12884927e-05 2.67824190e-05 3.93132222e-05]

:END:

How does this compare to the ground truth?

#+BEGIN_SRC ipython :session
t0 = 1
t14 = kit14_vals[2]
p_change = t0-t14
print(f"This would give the primary cell an expected loss of {(p_change*100)/14:.2f}% concentration per hour")
#+END_SRC

#+RESULTS:
:RESULTS:
# Out [997]:
# output
This would give the primary cell an expected loss of 5.00% concentration per hour

:END:


* Working on class based system

#+BEGIN_SRC ipython :session
  from network_diffusion import CellNetwork
  import numpy as np

  n=5
  m=5
  G = CellNetwork()

  for shape in ['rectangle', 'triangle', 'hexagon']:
      np.random.seed(1)
      G.generate_shape(shape, n=n,m=m)
      G.diffuse(0.5,1,10)
      fig, ax = plt.subplots(1, figsize=(8,8))
      sizes={k: np.around(v['C'],2) for k,v in G.nodes(data=True)}
      lbls = {}
      for k,v in sizes.items():
          lbls[k] = v if v > 0 else ''
      nx.draw(G, ax=ax, node_size=np.array(list(sizes.values()))*2000, labels=lbls, font_size=16, node_color='y')
      ax.set_title(shape)


#+END_SRC

#+RESULTS:
:RESULTS:
# Out [674]:
# text/plain
: <Figure size 576x576 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/f05261b0d5ed8fa87aa6c1e52f6fb1859ecea136.png]]

# text/plain
: <Figure size 576x576 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/4e34e63cc69810dbea8d4e1f57826cd2ffcda51a.png]]

# text/plain
: <Figure size 576x576 with 1 Axes>

# image/png
[[file:obipy-resources/56773090603b540ad23ab6991459ad9ca442b699/50d00dfb7c45dd8b00036780af4038b1041043cb.png]]
:END:
